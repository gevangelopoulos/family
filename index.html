
<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box; /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }

        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }

        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #4CAF50;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #152345;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">
<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr" />

            <form id="staticrypt-form" action="#" method="post">
                <div class="staticrypt-password-container">
                    <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                    />

                    <img
                            class="staticrypt-toggle-password-visibility"
                            alt="template_toggle_show"
                            title="template_toggle_show"
                            src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                    />
                </div>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator =
        ((function(){
            const exports = {};
            const cryptoEngine = ((function(){
                const exports = {};
                const { subtle } = crypto;

                const IV_BITS = 16 * 8;
                const HEX_BITS = 4;
                const ENCRYPTION_ALGO = "AES-CBC";

                /**
                 * Translates between utf8 encoded hexadecimal strings
                 * and Uint8Array bytes.
                 */
                const HexEncoder = {
                    /**
                     * hex string -> bytes
                     * @param {string} hexString
                     * @returns {Uint8Array}
                     */
                    parse: function (hexString) {
                        if (hexString.length % 2 !== 0) throw "Invalid hexString";
                        const arrayBuffer = new Uint8Array(hexString.length / 2);

                        for (let i = 0; i < hexString.length; i += 2) {
                            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                            if (isNaN(byteValue)) {
                                throw "Invalid hexString";
                            }
                            arrayBuffer[i / 2] = byteValue;
                        }
                        return arrayBuffer;
                    },

                    /**
                     * bytes -> hex string
                     * @param {Uint8Array} bytes
                     * @returns {string}
                     */
                    stringify: function (bytes) {
                        const hexBytes = [];

                        for (let i = 0; i < bytes.length; ++i) {
                            let byteString = bytes[i].toString(16);
                            if (byteString.length < 2) {
                                byteString = "0" + byteString;
                            }
                            hexBytes.push(byteString);
                        }
                        return hexBytes.join("");
                    },
                };

                /**
                 * Translates between utf8 strings and Uint8Array bytes.
                 */
                const UTF8Encoder = {
                    parse: function (str) {
                        return new TextEncoder().encode(str);
                    },

                    stringify: function (bytes) {
                        return new TextDecoder().decode(bytes);
                    },
                };

                /**
                 * Salt and encrypt a msg with a password.
                 */
                async function encrypt(msg, hashedPassword) {
                    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                    const encrypted = await subtle.encrypt(
                        {
                            name: ENCRYPTION_ALGO,
                            iv: iv,
                        },
                        key,
                        UTF8Encoder.parse(msg)
                    );

                    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
                }
                exports.encrypt = encrypt;

                /**
                 * Decrypt a salted msg using a password.
                 *
                 * @param {string} encryptedMsg
                 * @param {string} hashedPassword
                 * @returns {Promise<string>}
                 */
                async function decrypt(encryptedMsg, hashedPassword) {
                    const ivLength = IV_BITS / HEX_BITS;
                    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                    const encrypted = encryptedMsg.substring(ivLength);

                    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                    const outBuffer = await subtle.decrypt(
                        {
                            name: ENCRYPTION_ALGO,
                            iv: iv,
                        },
                        key,
                        HexEncoder.parse(encrypted)
                    );

                    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
                }
                exports.decrypt = decrypt;

                /**
                 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                 *
                 * @param {string} password
                 * @param {string} salt
                 * @returns {Promise<string>}
                 */
                async function hashPassword(password, salt) {
                    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                    let hashedPassword = await hashLegacyRound(password, salt);

                    hashedPassword = await hashSecondRound(hashedPassword, salt);

                    return hashThirdRound(hashedPassword, salt);
                }
                exports.hashPassword = hashPassword;

                /**
                 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
                 * compatibility.
                 *
                 * @param {string} password
                 * @param {string} salt
                 * @returns {Promise<string>}
                 */
                function hashLegacyRound(password, salt) {
                    return pbkdf2(password, salt, 1000, "SHA-1");
                }
                exports.hashLegacyRound = hashLegacyRound;

                /**
                 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
                 * remember-me/autodecrypt links, we need to support going from that to more iterations.
                 *
                 * @param hashedPassword
                 * @param salt
                 * @returns {Promise<string>}
                 */
                function hashSecondRound(hashedPassword, salt) {
                    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
                }
                exports.hashSecondRound = hashSecondRound;

                /**
                 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
                 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
                 *
                 * @param hashedPassword
                 * @param salt
                 * @returns {Promise<string>}
                 */
                function hashThirdRound(hashedPassword, salt) {
                    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
                }
                exports.hashThirdRound = hashThirdRound;

                /**
                 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                 *
                 * @param {string} password
                 * @param {string} salt
                 * @param {int} iterations
                 * @param {string} hashAlgorithm
                 * @returns {Promise<string>}
                 */
                async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                    const keyBytes = await subtle.deriveBits(
                        {
                            name: "PBKDF2",
                            hash: hashAlgorithm,
                            iterations,
                            salt: UTF8Encoder.parse(salt),
                        },
                        key,
                        256
                    );

                    return HexEncoder.stringify(new Uint8Array(keyBytes));
                }

                function generateRandomSalt() {
                    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                    return HexEncoder.stringify(new Uint8Array(bytes));
                }
                exports.generateRandomSalt = generateRandomSalt;

                async function signMessage(hashedPassword, message) {
                    const key = await subtle.importKey(
                        "raw",
                        HexEncoder.parse(hashedPassword),
                        {
                            name: "HMAC",
                            hash: "SHA-256",
                        },
                        false,
                        ["sign"]
                    );
                    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                    return HexEncoder.stringify(new Uint8Array(signature));
                }
                exports.signMessage = signMessage;

                function getRandomAlphanum() {
                    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                    let byteArray;
                    let parsedInt;

                    // Keep generating new random bytes until we get a value that falls
                    // within a range that can be evenly divided by possibleCharacters.length
                    do {
                        byteArray = crypto.getRandomValues(new Uint8Array(1));
                        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                        parsedInt = byteArray[0] & 0xff;
                    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                    const randomIndex = parsedInt % possibleCharacters.length;

                    return possibleCharacters[randomIndex];
                }

                /**
                 * Generate a random string of a given length.
                 *
                 * @param {int} length
                 * @returns {string}
                 */
                function generateRandomString(length) {
                    let randomString = "";

                    for (let i = 0; i < length; i++) {
                        randomString += getRandomAlphanum();
                    }

                    return randomString;
                }
                exports.generateRandomString = generateRandomString;

                return exports;
            })());
            const codec = ((function(){
                const exports = {};
                /**
                 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
                 *
                 * @param cryptoEngine - the engine to use for encryption / decryption
                 */
                function init(cryptoEngine) {
                    const exports = {};

                    /**
                     * Top-level function for encoding a message.
                     * Includes password hashing, encryption, and signing.
                     *
                     * @param {string} msg
                     * @param {string} password
                     * @param {string} salt
                     *
                     * @returns {string} The encoded text
                     */
                    async function encode(msg, password, salt) {
                        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                        // it in localStorage safely, we don't use the clear text password)
                        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                        return hmac + encrypted;
                    }
                    exports.encode = encode;

                    /**
                     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                     * we don't need to hash the password multiple times.
                     *
                     * @param {string} msg
                     * @param {string} hashedPassword
                     *
                     * @returns {string} The encoded text
                     */
                    async function encodeWithHashedPassword(msg, hashedPassword) {
                        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                        // it in localStorage safely, we don't use the clear text password)
                        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                        return hmac + encrypted;
                    }
                    exports.encodeWithHashedPassword = encodeWithHashedPassword;

                    /**
                     * Top-level function for decoding a message.
                     * Includes signature check and decryption.
                     *
                     * @param {string} signedMsg
                     * @param {string} hashedPassword
                     * @param {string} salt
                     * @param {int} backwardCompatibleAttempt
                     * @param {string} originalPassword
                     *
                     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                     */
                    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                        const encryptedHMAC = signedMsg.substring(0, 64);
                        const encryptedMsg = signedMsg.substring(64);
                        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                        if (decryptedHMAC !== encryptedHMAC) {
                            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                            originalPassword = originalPassword || hashedPassword;
                            if (backwardCompatibleAttempt === 0) {
                                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                            }
                            if (backwardCompatibleAttempt === 1) {
                                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                            }

                            return { success: false, message: "Signature mismatch" };
                        }

                        return {
                            success: true,
                            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                        };
                    }
                    exports.decode = decode;

                    return exports;
                }
                exports.init = init;

                return exports;
            })());
            const decode = codec.init(cryptoEngine).decode;

            /**
             * Initialize the staticrypt module, that exposes functions callbable by the password_template.
             *
             * @param {{
             *  staticryptEncryptedMsgUniqueVariableName: string,
             *  isRememberEnabled: boolean,
             *  rememberDurationInDays: number,
             *  staticryptSaltUniqueVariableName: string,
             * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
             *
             * @param {{
             *  rememberExpirationKey: string,
             *  rememberPassphraseKey: string,
             *  replaceHtmlCallback: function,
             *  clearLocalStorageCallback: function,
             * }} templateConfig - object of data that can be configured by a custom password_template.
             */
            function init(staticryptConfig, templateConfig) {
                const exports = {};

                /**
                 * Decrypt our encrypted page, replace the whole HTML.
                 *
                 * @param {string} hashedPassword
                 * @returns {Promise<boolean>}
                 */
                async function decryptAndReplaceHtml(hashedPassword) {
                    const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
                    const { replaceHtmlCallback } = templateConfig;

                    const result = await decode(
                        staticryptEncryptedMsgUniqueVariableName,
                        hashedPassword,
                        staticryptSaltUniqueVariableName
                    );
                    if (!result.success) {
                        return false;
                    }
                    const plainHTML = result.decoded;

                    // if the user configured a callback call it, otherwise just replace the whole HTML
                    if (typeof replaceHtmlCallback === "function") {
                        replaceHtmlCallback(plainHTML);
                    } else {
                        document.write(plainHTML);
                        document.close();
                    }

                    return true;
                }

                /**
                 * Attempt to decrypt the page and replace the whole HTML.
                 *
                 * @param {string} password
                 * @param {boolean} isRememberChecked
                 *
                 * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
                 *   expose more information in the future we can do it without breaking the password_template
                 */
                async function handleDecryptionOfPage(password, isRememberChecked) {
                    const { staticryptSaltUniqueVariableName } = staticryptConfig;

                    // decrypt and replace the whole page
                    const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                    return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
                }
                exports.handleDecryptionOfPage = handleDecryptionOfPage;

                async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                    const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
                    const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                    const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                    if (!isDecryptionSuccessful) {
                        return {
                            isSuccessful: false,
                            hashedPassword,
                        };
                    }

                    // remember the hashedPassword and set its expiration if necessary
                    if (isRememberEnabled && isRememberChecked) {
                        window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                        // set the expiration if the duration isn't 0 (meaning no expiration)
                        if (rememberDurationInDays > 0) {
                            window.localStorage.setItem(
                                rememberExpirationKey,
                                (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                            );
                        }
                    }

                    return {
                        isSuccessful: true,
                        hashedPassword,
                    };
                }
                exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

                /**
                 * Clear localstorage from staticrypt related values
                 */
                function clearLocalStorage() {
                    const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                    if (typeof clearLocalStorageCallback === "function") {
                        clearLocalStorageCallback();
                    } else {
                        localStorage.removeItem(rememberPassphraseKey);
                        localStorage.removeItem(rememberExpirationKey);
                    }
                }

                async function handleDecryptOnLoad() {
                    let isSuccessful = await decryptOnLoadFromUrl();

                    if (!isSuccessful) {
                        isSuccessful = await decryptOnLoadFromRememberMe();
                    }

                    return { isSuccessful };
                }
                exports.handleDecryptOnLoad = handleDecryptOnLoad;

                /**
                 * Clear storage if we are logging out
                 *
                 * @returns {boolean} - whether we logged out
                 */
                function logoutIfNeeded() {
                    const logoutKey = "staticrypt_logout";

                    // handle logout through query param
                    const queryParams = new URLSearchParams(window.location.search);
                    if (queryParams.has(logoutKey)) {
                        clearLocalStorage();
                        return true;
                    }

                    // handle logout through URL fragment
                    const hash = window.location.hash.substring(1);
                    if (hash.includes(logoutKey)) {
                        clearLocalStorage();
                        return true;
                    }

                    return false;
                }

                /**
                 * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
                 * try to do it if needed.
                 *
                 * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
                 */
                async function decryptOnLoadFromRememberMe() {
                    const { rememberDurationInDays } = staticryptConfig;
                    const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

                    // if we are login out, terminate
                    if (logoutIfNeeded()) {
                        return false;
                    }

                    // if there is expiration configured, check if we're not beyond the expiration
                    if (rememberDurationInDays && rememberDurationInDays > 0) {
                        const expiration = localStorage.getItem(rememberExpirationKey),
                            isExpired = expiration && new Date().getTime() > parseInt(expiration);

                        if (isExpired) {
                            clearLocalStorage();
                            return false;
                        }
                    }

                    const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                    if (hashedPassword) {
                        // try to decrypt
                        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                        // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                        // the user fill the password form again
                        if (!isDecryptionSuccessful) {
                            clearLocalStorage();
                            return false;
                        }

                        return true;
                    }

                    return false;
                }

                async function decryptOnLoadFromUrl() {
                    const passwordKey = "staticrypt_pwd";
                    const rememberMeKey = "remember_me";

                    // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                    // since it sends the hashed password to the server which isn't needed)
                    const queryParams = new URLSearchParams(window.location.search);
                    const hashedPasswordQuery = queryParams.get(passwordKey);
                    const rememberMeQuery = queryParams.get(rememberMeKey);

                    const urlFragment = window.location.hash.substring(1);
                    // get the password from the url fragment
                    const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                    const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                    const rememberMeFragment = urlFragment.includes(rememberMeKey);

                    const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                    const rememberMe = rememberMeFragment || rememberMeQuery;

                    if (hashedPassword) {
                        return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                    }

                    return false;
                }

                return exports;
            }
            exports.init = init;

            return exports;
        })());
    ;
    const templateError = "template_error",
        templateToggleAltShow = "template_toggle_show",
        templateToggleAltHide = "template_toggle_hide",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0cb3907cdeeacd5712a84eeb34318ec13b955fafbb563dbf4161f0d7d7623d6ae5e81d05df97fca0f6b7188b0382dcf7d68fd6cf4a200eb06a638acdd84fea56a26e1af7df60fe718b1b2ff6fdf56af5faa19300ce4b7ae123780b78c84545328bb7c689fc6117417ea3765915eddab972562b595555723d19389236725170989156990d330da3b34772a0ce8dd0d1ff32683d8a1a143de2c2d2fe31e1a46a047ea20dde5561c11255887433e3ccb20e489c88ca3031d6d3ea4b98b9bc175a91c41b3361f71f320a099ab56d3443a7db1161f88602d892d0efcb02629156fcaf7d5c3f8f13921b89799013f31772622ac534dc664023cf4e3da327c4b5cd6649a24903143da07c0f74b058ccb4619c7e08785a609b17f4dd46d5dc61aaa1937150266160d06e93c3467473c511a98edec3a8669010b98762a4e88099bca9c2d775b8dd6d3aa79bc32ef2918538ed5f3a16b3799e1b0d600c63ec81bff65f111c765fbe789eeca44796c119d9d8741a88499456642b47fece43bb2d04aaa8d6558cf46f8ea72115f82dc4b4c7724d3f32bc79a2c8735904f483ee9f3e9853996b1234c0198537a468d698e2749aed2b1da833a7c789759d310d8b0caf69f18968dd6a9457f8b6179fab0f363594acf6e9616cad86113b9967a76c87c8d36fb5224fe44a040f9b49d02da714a2343f7282b77a048924b919fe0ab1d1b535268b28f91d0dc968698ea5fee3f04d7661d1f3eda9c6f2f586d0fc456bdcdeed12d2955222d154e7103b1567bbc0dcf2054989425fce02e0a67f4cdad3bbd73df5095863ad761bb045e91f42f3e82e2cd40d046134de8e4c1f476ceaab54ddf9c6b22d154ee737d13ea286bf5ed6da2ba0e00554e5d42d1d89161abff44aed3cee41a8fcdf2e59f31dacb3455b6140e7c684b87f95b0f795b4fab2a60d67e9b7ab933f1aac316531ed59a019c5dcde28021603135211a2a5ad6d8b02ed5373657546c28b22b2b74da1501f94c20a06c53d94688896edcf9d66928a0db9f9502070a90ed70cbeae20b8d0b113cce52460a0823c6ccb8786bc319c0d2b33b7c48fed7837171a9fb2e9bf12d6ffe7968c84c31ad06036433e922e6ce920240f3f6f080196e7e4ac1709fb586698d5e306b54a3d7f392320bbf22933a0a3d5f1911dc8373fb3e560372b11b59587ca179f12bdbceddd0b08b27cef2911563989651ce913b87647c1de41929b0751193fbb0c84b59215ae6122f701ae11003de5cd2944a7cc64f30f1d3800579cdbf26acc9d9ad582e5192277a737838a040a0de549feddff94a9f59478cabe7a9853f7a2284a0aa344e0a0da098e80c362559bdae6835956f98dc5ad04e7c4be9377eb47000cf859cc0c5f84a964d4b1ad285bd23b6f4f91fa9313bff57417c07b63bb4e7ef446d3e0585819f066f35307f1632af10de7945a0053ce2206f0f492d6f0f9406900ba7e0f49f675f79be1f014dcd55c7bd0607773a23a9ca1a879672bcdb42e76f0b7c1067a2a8979b06a572b2e8d0541120401da7f8b7bc8dc896795af8ec8a55e8f5bb91b135fa64cb8e446b7558be8d8e842c54f7c9a6a37d050623e5da69a3eb30c8a943b77375cffcbd5347262e2ba5e9fe28ad40e1b656e188bf7e1b2d40ade9e64a4272771b7e2bf460a5a791d095212ec4cfd444f3619ebb6199467d813e5e3af8130643134bd1230fc833629f5fb5e245c0fff0a7e26500f513426fa6adc1bba81f0cc2ec33c38d9e5032ed43369d89d21c8c8d84e70ba0d8c2a68ba3646ab8f521ee96166464557572ef05862fb56afc5eea9f7c9b084400ac93303b97df18ecd816ea2690eed5edacd8f568e60a173ade418a0be03939e88b651661bb9b7b95f1442b81b2a52120cd19c2c8ea75b02db10033c36b6659e9a2366112867d0a7d2f9036ac4faa365515b743dd103aeb8dd8c90047e3629cf9833bae50d5df8346faa39fc84b03af6d0f247dcf1266188f1da8acb6d0271c895f012e9c1f2fe81d68c0a78a5b689a0cb008242faf1fb6e6d6e2eefa8e1db263b2a5afc0f684bacb789a2ed83e40c55b01e488c3080fb95ec230698f7c8a1c19486d095c6418c8c077532fd96aead0da94c45f922584873377a84e8a590771d931638aa2a0d2ea485076e006fc218739e473a5fbed874f45136b4dccfb390b52e3132178a0bfdedc0928d4bf67704104782108df23377c0ca109d9fd51e80de6230cecd56256684aca92337138ba1d4f1b184412c47d28178da8fda734f4537cb60e0b22167223d9079f8446880a9cbc0d468edf9016ba27e2aa110bfb084967a61c42f6898baf9217938ba759af722a208081cecc1a7843cda443ea596a1f79442a7171ba5e3cd48338000af6d3c87ec52d2921766c2e9851031e65a9136dca4fced8e0b1791bd9e31c90b1f8900beddaaf0487963b603216fb32fc5dd4b51e5a4241a55769fd076e4b96436cae3dd10d6043ed97341d14e214988fe24eb3a00ca0c3837d2ed1d576d28d5bca623a32ce8f497c5750d123f89361614af831113f0c5790d2278a047bcdba9ee3bd4ccd479fb8d4c2924136e3889eda249b8070e9cf17b14b2c3df72235d746819da84651d2d5dbd31c39ef75722ae3fa9dcf3433c3f50d39f66e9926de5de9b2021707aceba99200fe0ce6fee3f1dd43856524cda8f315372884c537f998359fd4491bddce0673bff6eccb2de7329345ff0e89655289d40f2f2ff4fcbc34b15b59526c7b021b69c85fefb9b5ee18f7fd59db6d9fa6b0edb800eb0dc62d9350f8c9fc79f1b02d52f59f168f971a1220d60255714318ad02ceb7bae05ea79bf9b735430204f14b81f10d3898ab7353896a3cb8027ae9030f47edad3f5ef226957195a392fa6f2f69e956dc97c5c6a13cc4e6043d284fc0071e49147cb6be18409c56a7555e404bb5c0bd890666fd0191c04915827823d1a45cb7bad646a4f5b7197cf8f33cbeaaee16c8064e9813f11815aa8eede54024e6ad44a704e06240c3bff56ba084440cba897e4a930e3ac3a89798d51f288b9711f4bfb084e6c57645af740de7cd13b1da6a78d54042a1138443320a64f537b51d6ed92ac5c241d19e601d0ac12c8afc5330eca6009fd51e8d182c04bc54f3221f1f66796890c1b121f92883deb980f30870e6e5fd0f1c6b2138e039a9db393d69921ba2c1f2f9cc17d800bf80c1fb14282778eb6e87f1a3ba965c4acdb70465b0f619c28c940439cb47d8ac3440353e97f9f508de4479a692a80fefbc005cfe10be6a3d86f0dfd81f7b55c098ffc233c7786fbc6354c005870b503f7edf307d34a5d6901641d770a30f61c8a98d224b9f2463a165b8827be06f00ff62da6d02f1029c500cf5dd03738564901ad798762bf7287329032a2c97fca9822e91d838288d49837272895f41e62a98ee077239e1a66670990cc6f2f52e5239b985a189b9de0112add8ace8b2fb862c63a975b8992464b92fa781f92b0b06c80f1a50e7ff807c3a7de22e10d1139f67f64a63175b93a112d75f2a3278464fa45a63d808deb0624d3d745aef0a901af3f3df154e0cbb0b63c971e224853ac63c05f0730d66c00dae0ec11b29b2cb6c30d09c97011d9bf0b674d6ff62dbab4622783a1773e8d601c9ac6c413dcd0723efb8c046f0ba665e043f963f5f0627a31c70d0afb8a8f24168bfdb9c55c43627ac0f25c35cea4591e2c6fcc03cdc8da166b9c6d208b565d400e985eee89de3468f503fc854b3a3a8e3976af6071a55116daec1a5442d849d7da8da6e9b7ad73afce9ff69d9d1851333b915dfcb28d8cdf366eb7151552f57cbee8721f8c5452f15e3462bda0204f3cc2339f423b44eed95851f4e3a9ce304e6e69b094083506abe111e3b3e431f3d0175536f1988c1c26b3931908544918bbaca9c8efe1a651e372f4ca78b80ed377150943e89b25886c14446734c72bac9dfddc221aa0d0aab42ef8270340d6081441491e2c1744507b7fe33dc63f7a0289ad918c28e0f2f397e0561811dfea9daf1c4bbe5197c4482148326edf65b4b8154ac3bf7521bf224853c9bc318ddbf5596b45db7b770e27444769e53041a96fd2adf2c874e588aef3937d133489b91b41976ee5709f39a0dcdf6151c121125ab8cfac1c2d47bac35c1c79f93b40f88a0b29187028514bd9467fc122ef4d1f7ad431e6d6a118acb009796beeb12cae30a39a90436e3a1bdadf3cfa7337cd94d5acb5ca3d320da78265ef0d0ffbb9a70233ad8bcc6ae4e3d36c6dade2618e6c8251d369ff05c523d35ea4ae6dd594f07c33ac7b95516a5637ab58b00cc5101fd70b86ddc57da204311bf82eacb8d89d3d70d87dd9347cb237fdaf4b886ff85f1eb092208b4b75800b04228043724dc78f6043135d4a190aa19fe7d56fcc4ab9cb435e83ce8c91adbb833797ec2ecb0ea43f04bfb8b5b016fdbd3bec2908e7de13d1e51a83c107b33eb43490467857c7e7aede2e08e789470828aaaa7ce54ca8a301bb9d9b943006e7e5e2401f9906806b938247e073396100c15de9136102b7273dd9909bd7218e22c02bd362bf170867b981d3d6c6502cae7217e9e73e1649673778de16edee8c6c7c86af6953b4845fcef6b68db0fd8bb9f14172475975c21d0d9bb23d2a077233329c9cb9b346b2d7e716e3321d64c761d4cd70f4a99658c8847c124a8561b924ebf4ba1201061985be87f35fc6bd15c410f80815a088269325cc9cc0b58867e2b2dd668e9ec87fb278c6396b716e74b3127807b2d05ff2ad3f8eb1b705f1e875b27b97ff7796c8ce38f58e184f00602acd2ffc7de2dc8d8f65031f090a206a29b653cff928322198c0320ca88b2298b6e9915c3c38848fa3042d7261459856eb8653d5f5dd31ba3f09bb3739bc1d42f187a9eb1f21d773545461c138cdd1c07c434d8e383c9d4442ca18c4a44db1046a05c6bb967e48812de5933382f295dbd1a92a6270aeecbcb39d4f343e7b897c5492aa88c03f44b6aed34b7a5c90e68f1bf4b66bae32ad0cec8c289c1b7949894e13311560829d8edf4516f32b1c5ee92f0b0f44662236ebcf42ae576edcb8cfb5aefa195085e3721ef28a8080fb0809ddea0f859ed229a9e80a20c70073f919616b0296b551b9f53b7de8fddb3ce5188121ed0e9fefa2dfc58f0e306aa09fbbbb9c9d3dcb03e03be16b847b41aeec4fd939d9253327968863a80ca43752451812257af2cb849c9d7b397206968d9a55104bcb9b442f153c7d1f8cffc250aa46effbb1a807cf573e82d3930589def4bea13abc5a03cd29efe03247e360e25271e65334fa792c9d2490560eaaea62fb116b9996f1a5e3f800a843cf01402be20542024a363aed2d8234eb1a2b75dcc1bd813e002bbdd7a2a92a60f3bde10a3bc60dbeb3ce2ebc345754d8809302bcba2214c3c6874557a1c063609c6306337054a99bc7a1c9b5192f2669c319931fb5034d5b0dbcc7b1c49cac4d6a5502e6c75c55b21e2f73c281aa3a173082bdf3655d2a485a7216b7a90bc87f5101d813f3ed866dfcf9574c1c50996ed7408ba36bc6d6f70da170184d1d1363a1e4b7a0081ebbbce2bdb735d6eb295eeb71088ff87f792cd48d24c7b1f6b1650ee5d829ac0f1eb434a3af5e1d84191153f8a9352acf1edcefa7ab778486a9becbb7aea843c64aa951cb3a7dd6c9dbab4b1bcabb39033ad49062ce84ba9e6a396e0542aa72c40c01a4cc5b07035a32857f087f990a06d1a86f892e305e831ac4e1a58fd2d1f2ac948e0c31e256e5c6c609127809fe2312cd8411b92f7f5d172c733aa632e7df88d7b2cadb50b7d056740922ba48465ccf0079f24f93df32d9b46faa3876d9f372a7a1061adec1ac690ba34e6d42a6fe2ef5c716c3a3c4fe4a0b41e1ec7b62a076b48a96ff771e439fe9d6c06660cc2901b2f7a00330d8abb33beed1e83028fb5d8197393142b990e46c0cb9afc1cb33810aad828c5b6a9510aa6ba984481c6ffbb4060c1ee8d93198e58b0af4546edeb0b1fcc6eefd6d6c02a7d33243161232048757cf9e1874e1680a17029f2328773f20fbab7b702d56b9cd192c522974f60ca49ce99d7b14a80042512ccd9ade93b734321b8355daf072b4021d837ec3f9ef15c2a5803048f187beb4ad1274ca29ea6d6bd752a5dd6f7dfa0d04d9649357d626ad1a35513b9187c8d2ffd466b565e6b39293158c6e608371e65c6314a580941a5466f55ce66f7258a5148c5e6c0d691462b5e051c02f546543cc587f2683e2c95a1ccbaad84881b0fb7e3bc4087b8091eca7345317270b16ab560677e96541a392fc0e1795853f0a3f60d7244ea9179a8f56171a50316e89089f6bdb6185e41aa57f8fe211d6dc7e4753d3c3a33fe9a65dee05d52804b41db341dc8bbb66f16d8012afb7f55f75baa170fabc4f2d2d319e39eb2180f2b203c5fe3c452512fb51183ead90cf6bacd57ea9f98cfcf642ef71d3b7a183f5ce23aeb9d978e111478647ad67869d625ea65e8bcecff09a28d009adbbef7185b7c48d110d2e6ae9d7227272ef1b20acad460f0a390bca44c9a8bb09f0d8af5ba4e7615534480b7fc824f3c7c310d4520b6d5250a0f54970dfbcb15e6317c734ae4cade60810f7f3b5c4ab214f467677edcc7823a354de0efe152ff2120299e8062a66d1e17c1f4251aad68b228595e12bc9720755b61e6e1c3594a1c8fd24820efca25c75ca08f0d214946aa2d42bdea249fa019fe9dc42e47b1263cd6e496baa4e193f68b17b5750576dea17551fa6975157be2c7afcb3004586ee97f48d3d7778c9ed79405ee3944a5466580d30f87cdc4a5b742e3e1dc79cb6df805e46072ec0f0b996377d3d8cf8ef801230813506da3e1e0a53d3a9bcf8440879ce28d0014513691f5d80027eddf950382dd374c238219bf96e772694eabb1c5552bffd9996f5dc0e074c88c69c55e1730e3cff4f8aed2d1faa0539d0e60c6e15dd6c0208af85325d1a66afcb28e9f35a5a316e7adc55ef5e803001b42c6d8ebe7b9c33aa0c7c17d8d08e9bab9d2dbd1665a71a1de9def75f6a82de37a143250c5b74c28ee402a35c4822105d3ee1d4eb5f9121cc6b23a6d58cd7f40cdcbecb75b06a3b9683120a98ff8d6daaa682272ec7205c9c5c6a342a7a50c542307b99517dcbb385ffd4bf3c21a0007f356e78b7a4ac78c6e9eb64a96d928dfc7ea2f1ff5e38e00db4dd7a16aeac9c86657b6cada651139ed4bd3c7e8242b489eefc707ce497e376e63cae0dbee0c304a134830200d101ab66feb9553ab5e171e2534b61f60f7c6685a91f29d82ede15fb178c1a009400bfc230c91d279f943fe0d802da04f56fdb1e4989c0f14a85c1b4136a479871c90b0c9b5399974d41070657d25eec8d7a58f2e1506a06281f2c61f44d811beee198130ef55105b51a7b166dce647c784aeee725f016e56a43773c0dd39c3c90ce304ef8182a1f283582cae30b3421b027e68ddc589368feb45308d9124f315a0add7589edd68c7b87c79ed17aa4a1353e6f4b2e76430a5c4ccec2539c679713dc9113569a898bd8f22aee1acc6a3e30ead8933f88008d81d85e17481712ecbc366c846852900c09f5e00f986b80b46896421a562a574cad57c7f4544c449ce762b77e836db4048780b287a00bfad252e5d2ef6c8781846f8b9fe7bb470a54562670f543f1fa747b72d9dfb17f9c1da06c4d318c57e349696b55adee1faf6cabcc2997d85200246827fb06e8c4af3b3fba336924c669f2fc91bf24eeb7a3250bd49988068f475f380f6ee39cb0ca8b8c0168a40b2ec330f3376b22235086050ac98ec4805a8488257c75d5a1bf17c28aac2fcbde16a44446fd9bfaa51c3440f22a43f350f773132afe95df9db1b3d3a5fa3dafa99bf2b1a33cfa841f8c1953be14bf9fd455031ce92982c5464bff5f8940811b1a0fb599afcb1f28f84e9e6404d10fd5cf2b46eb73bfb865e136d573f341cd847cbd5e7087c912390c4451488861d126cc159055c05222443013bd7ba4ae5241c5b35bcb7a92d79b9a20e27de2f6b73fce4da1a6750f6803731e898eb80e043d163b4969f33b67d1babe8c858258524cdb43c314f8d4a02f059d9dfb101d28e18ed1ff96867759b4fa3c3a1841321829d8042715734ec89fe2957908b92b9f2ba3193efc6353699e085125814aef945f416417d406309236359de9eea26eb96ceffbd0aa1acfca625109a404921f8cfd8d1a73bf5e7c8911aa1a7445748b4a0c16eb077189e746a5aecd426909b934108355e1c6166cf6272b44ffe12734fd6c5b4c40a29969b2ede694e147be0d89491f9b244237c061c17cafd41f0c873373243da5b2390ab6088c758fc32183952b62e7e139c3bac08e92d2dd66171b7430b062b307fadf6740f3d431b5f8304f4309d131d1d46e510c087fe23f9687cc023183f77c7155f22c99c82dc3d9ae295ef09f8e952231797cc33b8426c6d9c388490d8da093d7782f54f4c2b77fd34f6084d487d3d2ce15d9a732893202d516ac7581262fca001ccef63cd908c2f08e62e4281c6e3ed4e6e660018eab080c0fad0a84985661682a560a44ce80e8167ff0a4e2b0f8e0706ca49c4ffc023b5b1f3e03b79b5c7281c6153b5558b3964dacb62fb58e0806d8cc582d1c8427845a5094fa3010dd6390199639073c716fc3a218cbe1be3331f216800afff2d99d493be2a1881beb1f229e9f0a612e22579ca3dc532caac7e404db64ff6c3ee3b46d7167acbbead7c7f0f23e5e3cb11ad11b98f4631e55e5724a81567ca64dca7c1c64d897c56c9cf1f6692f8f6f86ae2951f6348fe525e265862c57cc3aa85a320bb1d29dd91f24538101c86f665cce9f7b928b84fc3810decc4c13d94857af48d811af8cfaaab6b1f5a0e472cf5d8245fcc4dae3b8bbd65b40deb183e74249d298a8d5708baf8757e07ceee6727392ac8d49db58116bfcfeaf2c19fd0faec273db6600bf36e0f8a95d6fc8bf389b4bb0518818284eb98728448d8ce8b607f8289104cc41d43813d638fc77b9b99abdde6e981f70f04237645a2e2ca249fa6095d00dfb8dc41723a7561b85317a8e09b6be25571889d7f04dfbb019685e5179241a699b8eeb0611853094b5f20b95112337a07c77326a78bd15075d642469d2953c4433092660843c82fa1ffda8abc5b64c5072b3ba548a5260caa8aadc636a3f4827d06025000451e7a4bbfe6cd0af098018a78b016d443ff8303f70cccd8444a3dbd8e699a5ae648e4d06036531be9fd1f0c5e4c53af6a7f0691bf27432d10472109c8a2a3cb569efa0167bedaec6b17fa1b26ca16e2a6746f1220b863cf7903671e5ca037c481d2261717ab1cec54c37e4d1efb8db8f3eeee918632f63263203d917aa370658bee11989a9a30067137657fdc8707defb2ee3f076e83e3da0cc95a64380ab5bb687a8c1c3782cfcbe641e737eb4b774c834cb190daa506341c2847b4c1ca038ebefdee7558ba9c79a103793495e28d70f95c2c1938ca4fd837c82dbd2cf4d973fb67fb7272037d3bff97f3e045c5a7ef68435f1a7e46efa6b402cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"7a64f7ab0d6fd01107c8958f25712802"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("hidden");
            }
        }
    };

    // toggle password visibility
    const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
    // these two icons are coming from FontAwesome
    const imgSrcEyeClosed =
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
    const imgSrcEyeOpened =
        "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
    toggleIcon.addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
            toggleIcon.src = imgSrcEyeOpened;
            toggleIcon.alt = templateToggleAltHide;
            toggleIcon.title = templateToggleAltHide;
        } else {
            passwordInput.type = "password";
            toggleIcon.src = imgSrcEyeClosed;
            toggleIcon.alt = templateToggleAltShow;
            toggleIcon.title = templateToggleAltShow;
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
